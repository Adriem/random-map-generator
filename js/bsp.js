// Generated by CoffeeScript 1.9.2
(function() {
  var Tree, cfg, generateMap, generatePaths, generateRooms, spawnRoom, split;

  cfg = {
    ITERATIONS: 4,
    RATIO_RESTR: 0.45,
    PARTITION_LEVEL: 2,
    ROOM_REDUCTION: 0.4,
    ROOM_MIN_SIZE: 5,
    SECTOR_MIN_SIZE: 9,
    SECTOR_MAX_SIZE: 16,
    BIG_ROOM_CHANCE: 25,
    ROOM_DELETING_RATIO: 0.4,
    DOOR_CHANCE: 60
  };

  Tree = (function() {
    function Tree(node1) {
      this.node = node1;
      this.childs = [];
    }

    Tree.prototype.isEmpty = function() {
      return this.node == null;
    };

    Tree.prototype.isLeaf = function() {
      return this.childs.length === 0;
    };

    Tree.prototype.getLeafs = function() {
      var child, j, len, ref, retVal;
      if (this.isLeaf()) {
        return [this];
      }
      retVal = [];
      ref = this.childs;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        retVal = retVal.concat(child.getLeafs());
      }
      return retVal;
    };

    Tree.prototype.getNodeList = function() {
      var child, j, len, ref, retVal;
      retVal = [this.node];
      ref = this.childs;
      for (j = 0, len = ref.length; j < len; j++) {
        child = ref[j];
        retVal = retVal.concat(child.getNodeList());
      }
      return retVal;
    };

    Tree.prototype.kill = function() {
      this.node = void 0;
      this.childs = [];
      return void 0;
    };

    Tree.prototype.removeDeadLeafs = function() {
      var child, i, j, ref;
      if (!this.isLeaf()) {
        ref = this.childs;
        for (i = j = ref.length - 1; j >= 0; i = j += -1) {
          child = ref[i];
          child.removeDeadLeafs();
          if (child.isLeaf() && child.isEmpty()) {
            this.childs.splice(i, 1);
          }
        }
      }
      return void 0;
    };

    Tree.prototype.grow = function(iterations, splitFunction) {
      var childNodes, j, len, node, ref;
      if (iterations > 0) {
        childNodes = splitFunction(this.node);
        if ((childNodes != null) && (0 < (ref = childNodes.length) && ref <= 1)) {
          this.node = childNodes[0];
        } else if ((childNodes != null) && childNodes.length > 1) {
          for (j = 0, len = childNodes.length; j < len; j++) {
            node = childNodes[j];
            this.childs.push(new Tree(node).grow(iterations - 1, splitFunction));
          }
        }
      }
      return this;
    };

    return Tree;

  })();

  generateMap = function(size, c) {
    var paths, rooms, tilemap, tree;
    tilemap = new TileMap(size, size);
    tree = new Tree(new Rect(0, 0, size, size)).grow(cfg.ITERATIONS, split);
    rooms = generateRooms(tree, tilemap);
    tree.removeDeadLeafs();
    paths = generatePaths(tree, tilemap);
    tilemap.drawWalls();
    return tilemap.paint(c);
  };

  spawnRoom = function(sector) {
    var h, reduction, w, x, y;
    reduction = Math.min(Math.floor(sector.w * cfg.ROOM_REDUCTION, Math.floor(sector.h * cfg.ROOM_REDUCTION)));
    x = sector.x + utils.randomValue(2, reduction);
    y = sector.y + x - sector.x;
    w = sector.w - 2 * (x - sector.x);
    h = sector.h - 2 * (y - sector.y);
    return new Rect(x, y, w, h);
  };

  generateRooms = function(tree, tilemap) {
    var i, index, j, k, leaf, leafs, len, ref, rooms, roomsToDelete, x;
    rooms = [];
    leafs = tree.getLeafs();
    roomsToDelete = Math.round(leafs.length * cfg.ROOM_DELETING_RATIO);
    for (x = j = 0, ref = roomsToDelete; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      index = utils.randomValue(leafs.length);
      leafs[index].kill();
      leafs.splice(index, 1);
    }
    for (i = k = 0, len = leafs.length; k < len; i = ++k) {
      leaf = leafs[i];
      rooms[i] = spawnRoom(leaf.node);
      tilemap.drawRect(rooms[i]);
    }
    return rooms;
  };

  generatePaths = function(tree, tilemap) {
    var _, i, j, k, len, len1, path, paths, sectorList;
    paths = [];
    sectorList = tree.getNodeList();
    for (i = j = 0, len = sectorList.length; j < len; i = ++j) {
      _ = sectorList[i];
      paths.push(new Path(sectorList[i].center, sectorList[(i + 1) % sectorList.length].center));
    }
    for (k = 0, len1 = paths.length; k < len1; k++) {
      path = paths[k];
      tilemap.drawPath(path);
    }
    return paths;
  };

  split = function(sector, horizontalDir, steps) {
    var div1, div2, restriction;
    if (horizontalDir == null) {
      horizontalDir = utils.randomTest();
    }
    if (steps == null) {
      steps = cfg.PARTITION_LEVEL;
    }
    if (horizontalDir) {
      if (sector.h / sector.w < 2 * cfg.RATIO_RESTR) {
        return split(sector, !horizontalDir, steps);
      } else if ((steps === 0) || (sector.h < cfg.SECTOR_MAX_SIZE && utils.randomTest(cfg.BIG_ROOM_CHANCE)) || (sector.h < 2 * cfg.SECTOR_MIN_SIZE)) {
        return [sector];
      } else {
        restriction = Math.max(cfg.ROOM_MIN_SIZE, Math.ceil(sector.h * cfg.RATIO_RESTR));
        div1 = new Rect(sector.x, sector.y, sector.w, utils.randomValue(restriction, sector.h - restriction));
        div2 = new Rect(sector.x, sector.y + div1.h, sector.w, sector.h - div1.h);
      }
    } else {
      if (sector.w / sector.h < 2 * cfg.RATIO_RESTR) {
        return split(sector, !horizontalDir, steps);
      } else if ((steps === 0) || (sector.w < cfg.SECTOR_MAX_SIZE && utils.randomTest(cfg.BIG_ROOM_CHANCE)) || (sector.w < 2 * cfg.SECTOR_MIN_SIZE)) {
        return [sector];
      } else {
        restriction = Math.max(cfg.ROOM_MIN_SIZE, Math.ceil(sector.w * cfg.RATIO_RESTR));
        div1 = new Rect(sector.x, sector.y, utils.randomValue(restriction, sector.w - restriction), sector.h);
        div2 = new Rect(sector.x + div1.w, sector.y, sector.w - div1.w, sector.h);
      }
    }
    return split(div1, !horizontalDir, steps - 1).concat(split(div2, !horizontalDir, steps - 1));
  };


  /* EXPORT */

  this.BSP = {
    config: cfg,
    generate: generateMap,
    Tree: Tree
  };

}).call(this);

//# sourceMappingURL=bsp.js.map
